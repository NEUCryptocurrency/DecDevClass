1. First we analysed the [Ballot.sol](https://solidity.readthedocs.io/en/v0.4.25/solidity-by-example.html) contract, the default contract to appear in the [Remix IDE](http://remix.ethereum.org/). We discussed how current elections have centralist components that are single points of failure and vulnerable to manipulation - so perhaps a trustless smart contract could do better! We then read through the contract to familiarise ourselves with some Solidity code - the syntax, and general design patterns. We specifically pointed out some key design choices:
     a. The author first designated what roles are involved in his smart contract's system. This included some custom data structures, created via the struct keyword, to represent concepts like a Voter. He also broke out specific roles involving authority, such as the chairperson.
     b. The constructor of the smart contract took in all proposals as a parameter - evidently, it wouldn't make sense to run an election that has no options to vote on. The takeaway, then, is that smart contract constructors should take in enough input to run a full-fledged operation.
     c. Finally, the author provided specific functions to allow roles with authority to "promote" other users to a level of authority - but these functions always checked the function caller (via msg.sender) to ensure they had the authority they were claiming.

2. Next, we began to code our first smart contract! We did so iteratively, beginning with an extremely simple contract, and adding complexity at each step. This process highlighted specific issues that smart contract developers have to deal with. We did all coding, deployment, and testing in [Remix](http://remix.ethereum.org/). If you missed class, I encourage you to try to reproduce the code yourself at each step, rather than copy-pasting the example code - the best way to learn Solidity is to code it yourself. You can compile your code as you go using the side-bar on the right, and then test by jumping to the sidebar's "Run" tab and pressing the Deploy button.
     a. Our very first version was a contract that took a number as input in its constructor, and made it publicly available. So, if you wanted to store a numerical value forever on the blockchain, you could deploy this contract with your special value and then call the function to see that number. Note that "public" field variables automatically generate a function for viewing them, which is called by its name - ie, if you have a public variable named "specialNum", you can see it via contract.specialNum(). See the code [here](https://github.com/NEUCryptocurrency/DecDevClass/blob/master/Oct20/Storage1.sol)
    b. Next, we wanted to add a way to change the number - so we wrote a function to do that, which took in a new number, and updated the field variable. See the code [here](https://github.com/NEUCryptocurrency/DecDevClass/blob/master/Oct20/Storage2.sol)
    c. However, that version lets anyone in the world change our number! Sounds chaotic. So let's only let the contract's deployer change the number. We record the user who deployed this contract by accessing msg.sender in the constructor function - because deploying a contract, on a protocol level, is the same as calling its constructor function. In our updateNumber function, we use the require keyword to ensure the person calling the function is the deployer. See the code [here](https://github.com/NEUCryptocurrency/DecDevClass/blob/master/Oct20/Storage3.sol)
     d. Finally, we want to let the contract's deployer appoint other people who are allowed to change the number. This means we need to record their addresses in a list, and check that list when someone tries to change the number. That also means being able to efficiently loop through the list. It also means making sure that we strictly control who is allowed to appoint other roles - we don't want people appointed to set the number to also be able to appoint other setters! That could be chaotic. See the code [here](https://github.com/NEUCryptocurrency/DecDevClass/blob/master/Oct20/Storage4.sol)

So, our end result was a smart contract where the contract deployer can initialise its stored number, and can update it themselves, or appoint people who are allowed to update it as well. This may seem silly, but has analogous applications to any kind of important data storage - customer info, secrets, research, and so on.
